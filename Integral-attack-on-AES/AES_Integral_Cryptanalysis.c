/* ========================================
	AES-256 分组长度为128，密钥长度为256，迭代轮数为14轮 
	Integral cryptanalysis on 4-round AES:
	
	1) 	Choose 256 plaintext having equal values
	   	in 15 bytes and different values in one bye. 

	2)  Get the 256 ciphertexts; encrypted with a
		secret key using 4-rounds AES.
   ========================================*/

//#include "sbox.h"
//#include "aes.h"
#include <inttypes.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// AES S-Box 16*16=2^8
unsigned char S[] = {																				 // idx range:
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,  // 0  - 15
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,  // 16 - 31
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,  // 32 - 47
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,  // 48 - 63
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,  // 64 - 79
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,  // 80 - 95
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,  // 96 - 111
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,  // 112 - 127
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,  // 128 - 143
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,  // 144 - 159
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,  // 160 - 175
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,  // 176 - 191
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };

// AES Inverse S-Box
unsigned char SI[] = { 
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D };

//输出状态 
void printState(unsigned char * state);

//AES加密 
void AES_enc(unsigned char * plaintext, unsigned char * roundkey, unsigned char * state, unsigned char * S, int rounds);

//密钥加 
void addRoundKey(unsigned char * roundkey, unsigned char * state);

//字节替换 
void subBytes(unsigned char * state, unsigned char * S);

//行移位 
void shiftRows(unsigned char * state);

//逆行移位 
void invShiftRows(unsigned char * state);

unsigned char mulBy02(unsigned char * ptr);

//列混合 
void mixColumns(unsigned char * M, unsigned char * state);


// 4x4 matrix in GF(2^8)
unsigned char M[] = {
	0x02, 0x01, 0x01, 0x03,
	0x03, 0x02, 0x01, 0x01, 
	0x01, 0x03, 0x02, 0x01,
	0x01, 0x01, 0x03, 0x02
};

/* =========================================
	Function definitions
   ========================================= */

//输出加密过程中的状态值 
void printState(unsigned char * state){
	int i;
	
	for(i=0; i<16; i++){
		printf("%x \t",state[i]);
	}
	printf("\n\n");
}

/* =========================================
	AES Encryption / Decryption subfunctions
   ========================================= */

//密钥加	
void addRoundKey(unsigned char * roundkey, unsigned char * state){
	uint8_t i;
		
	for(i=0; i<16; i++){
		state[i] ^= roundkey[i];
	}
}

//字节替换 
void subBytes(unsigned char * state, unsigned char * S){
	
	uint8_t i;
	uint8_t a, b, idx;					//entries to S-box
	
	for(i=0; i<16; i++){
		
		// mask first and last four bits for a,b entries
		a = (uint8_t)(state[i] & 0xf0);//11110000获取前四位 
		a = a >> 4;
		
		b = (uint8_t)(state[i] & 0x0f);//00001111获取后四位 

		// S-box lookup
		idx = ((16*a)+b);
		state[i] = S[idx];//S盒操作 
	}
}

//行移位 
void shiftRows(unsigned char * state){
	
	uint8_t i, j;
	unsigned char tmp[16];
	
	for(j=0;j<4;j++){
		for(i=0;i<4;i++){
			// shift left by i bytes 
			if(j-i<0){
				tmp[i+4*(4+(j-i))] = state[i+4*j];
			}
			else{
				tmp[i+4*(j-i)] = state[i+4*j];
			}
		}
	}
	// copy shifted array to AES state vector	
	for(j=0;j<4;j++){
		for(i=0;i<4;i++){
			state[i+4*j] = tmp[i+4*j];
		}
	}
	
}

//逆行移位 
void invShiftRows(unsigned char * state){
	
	int i, j;
	unsigned char tmp[16];
	
	for(j=0;j<4;j++){
		for(i=0;i<4;i++){
			// shift right by i bytes 
			if(3-(j+i)<0){
				tmp[i+4*(j+i-4)] = state[i+4*j];
			}
			else{
				tmp[i+4*(j+i)] = state[i+4*j];
			}
		}
	}
	// copy shifted array to AES state vector
	for(j=0;j<4;j++){
		for(i=0;i<4;i++){
			state[i+4*j] = tmp[i+4*j];
		}
	}
}

//列混合 
void mixColumns(unsigned char * M, unsigned char * state){
	
	unsigned char state_out[16] = { 0x0 };
	
	int i,j,k;
	unsigned char mult; 
	
	for(i=0; i<4; i++){
		for(j=0; j<4; j++){
			
			// Calculate i,j state_out vector
			for(k=0; k<4; k++)
			{
				mult = M[i+k*4];
				
				if(mult == 0x01)
				{
					state_out[i+j*4] ^= state[k+j*4];
						
				} 
				else if(mult == 0x02)
				{
					state_out[i+j*4] ^= mulBy02(&state[k+j*4]);
					
				} 
				else 
				{
					state_out[i+j*4] ^= ( mulBy02(&state[k+j*4]) ) ^ state[k+j*4];
				}
			}
		}
	}
	// copy temporary state array to AES state vector
	for(j=0;j<4;j++){
		for(i=0;i<4;i++){
			state[i+4*j] = state_out[i+4*j];
		}
	}
}


unsigned char mulBy02(unsigned char * ptr){
	unsigned char val;
	
	//0x02*x <=> ( (x<<1) XOR 0x1B ) iff MSB of x == 1	(where x is an 8-bit value)
	if( (0x80 & *ptr) == 0x80 ){
			val = ((*ptr << 1) ^ 0x1B);
		} else {
			val = *ptr << 1;
		}
	
	return val;
}

/* ==================================
	AES encryption
   ================================== */
// ought to modify to just work on one global array and one local; input global vector, allocate local to work on, then cpy
// .. encrypted vector to global input vector and return 
void AES_enc(unsigned char * plaintext, unsigned char * roundkey, unsigned char * state, unsigned char * S, int rounds){
		
	int i;
	
	// Initialize state vector
	for(i=0; i<16; i++)
		state[i] |= plaintext[i];

	addRoundKey(roundkey, state);

	
	// Round 1 to n-1
	for(i=1; i<=rounds-1; i++){
		subBytes(state, S);
		shiftRows(state);
		mixColumns(M, state);
		addRoundKey(&roundkey[i*16], state);
	}
	
	// Last round
	subBytes(state, S);
	shiftRows(state);
	addRoundKey(&roundkey[i*16], state);
}

//Integral cryptanalysis

// Function prototypes
void integral(unsigned char * ciphertext_set, int rk_byte_num);
int roundKeyFound(unsigned char * candidates, int n);
unsigned char * initPlaintextSet(unsigned char * plaintext_set, int constant);
unsigned char * resetCiphertextSet(unsigned char * ciphertext_set);

// Expanded key (using https://www.cryptool.org/en/cto-highlights/aes)
unsigned char roundkeys[] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, //r0 (cipherkey)
	0xd6, 0xaa, 0x74, 0xfd, 0xd2, 0xaf, 0x72, 0xfa, 0xda, 0xa6, 0x78, 0xf1, 0xd6, 0xab, 0x76, 0xfe, //r1
	0xb6, 0x92, 0xcf, 0x0b, 0x64, 0x3d, 0xbd, 0xf1, 0xbe, 0x9b, 0xc5, 0x00, 0x68, 0x30, 0xb3, 0xfe, //r2
	0xb6, 0xff, 0x74, 0x4e, 0xd2, 0xc2, 0xc9, 0xbf, 0x6c, 0x59, 0x0c, 0xbf, 0x04, 0x69, 0xbf, 0x41,	//r3
	0x47, 0xf7, 0xf7, 0xbc, 0x95, 0x35, 0x3e, 0x03, 0xf9, 0x6c, 0x32, 0xbc, 0xfd, 0x05, 0x8d, 0xfd //r4
};

/*
unsigned char roundkeys2[] = {
	0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,
	0x79, 0x72, 0x6e, 0x77, 0x72, 0x78, 0x67, 0x7f, 0x75, 0x7e, 0x62, 0x7b, 0x76, 0x7c, 0x63, 0x7b,
	0x6b, 0x89, 0x4f, 0x4f, 0x19, 0xf1, 0x28, 0x30, 0x6c, 0x8f, 0x4a, 0x4b, 0x1a, 0xf3, 0x29, 0x30,
	0x62, 0x2c, 0x4b, 0xed, 0x7b, 0xdd, 0x63, 0xdd, 0x17, 0x52, 0x29, 0x96, 0x0d, 0xa1, 0x00, 0xa6,
	0x58, 0x4f, 0x6f, 0x3a, 0x23, 0x92, 0x0c, 0xe7, 0x34, 0xc0, 0x25, 0x71, 0x39, 0x61, 0x25, 0xd7
};*/

// Input
unsigned char plaintext_set[4352] = { 0 };				// A set of 256 plaintexts of 16 bytes plus extra 256 bytes buffer, 256*16+256
unsigned char ciphertext_set[4352] = { 0 };

unsigned char candidates[256] = {[0 ... 255] = 0x01 }; // Assume all candidates and rule out as we integrate over multiple sets
unsigned char found_roundkey[16] = { 0 };			   // Last roundkey result
int rk_byte_num = 0;								   // Roundkey byte to be computed


// Function definitons
void integral(unsigned char * ciphertext_set, int rk_byte_num){
	
	int i, rk, ct;
	
	unsigned char tmp[4352];
	unsigned char roundkey_guess[16] = { 0x00 };
	
	unsigned char sum;
	unsigned char tmp_candidates[256] = { 0x0 };
		
	// Integrate for each round key (rk)
	for(rk=0; rk<256; rk++){
		
		// Copy ciphertext set to local scope for each rk value
		memcpy(tmp, ciphertext_set, 4352);
		
		// Initialize sum and round key guess for this loop-round
		sum = 0x00;	
		roundkey_guess[0] = (unsigned char) rk;
			
		// Compute with key guess on all ciphertexts values for one byte at a time
		for(ct=0; ct<256; ct++){
			
			// Compute backwards through last special round of AES
			addRoundKey(roundkey_guess, &tmp[ct*16+rk_byte_num]);				// addRoundKey is self-inverse		
			invShiftRows(&tmp[ct*16+rk_byte_num]);								// row i shifted i bytes to the right
			subBytes(&tmp[ct*16+rk_byte_num], SI);								// substitute using inverse S-box
			
			sum ^=tmp[ct*16+rk_byte_num];										// xor-summation of sub-results
		}
		
		// If guessed rk computed on all values of the ciphertext set sums to 0 then rk is a candidate
		if(sum == 0){
			tmp_candidates[rk] = 0x01;
		} else {
			tmp_candidates[rk] = 0x00;
		}
	}
	
	// Once done testing for each rk on the given ciphertext set, rule out candidates not in tmp_candidates
	for(i=0; i<256; i++){
		candidates[i] *= tmp_candidates[i];
	}
}

int roundKeyFound(unsigned char * candidates, int n){
	int i, sum;
	
	sum = 0;
	
	// candidates (cand) contain 0s and 1s; 1 => value is cand and 0 => value is not a cand
	for(i=0; i<256; i++){
		sum += candidates[i];
	}
	
	// If n candidates are found we are done
	if(sum == n)
		return 1;
	else
		return 0;
}

unsigned char * initPlaintextSet(unsigned char * plaintext_set, int constant){
	
	int i = 0;
	int j=0,k=0;
	// Initialize chosen plaintexts with the i'th byte different rest as constant
	memset(plaintext_set, constant, 4352);//初始化为0 
	for(i=0; i<256; i++){
		plaintext_set[i*16] = i;
	}
	for(j=0;j<256;j++)
	{
		for(k=0;k<16;k++)
			printf("%d ",plaintext_set[j*16+k]);
		printf("\n");	
	}
	
	return plaintext_set;
}

unsigned char * resetCiphertextSet(unsigned char * ciphertext_set){
	return memset(ciphertext_set, 0, 4352);
}



int main()
{
	int i, n;
	
	int c = 0;	// Constant value for plaintext set
	
	while(rk_byte_num < 16)
	{
		
		// Make plaintext sets and search for roundkey byte until only one candidate left for that one byte
		while(!roundKeyFound(candidates, 1))//candidates之和不为1时，while为真。其实就是执行一次while里面的操作。 
		{
			
			initPlaintextSet(plaintext_set, c);
		
			// Encrypt plaintext sets and save to corresponding ciphertext sets (16 bytes at a time)
			for(i=0; i<256; i++){
				AES_enc(&plaintext_set[i*16], roundkeys, &ciphertext_set[i*16], S, 4);
			}
		
			// Attack: find candidate for a single byte
			integral(ciphertext_set, rk_byte_num);
		
			// Reset ciphertext set in order to operate with a new one later
			c++;						//use incrementer as the one byte value that should differ in sets
			resetCiphertextSet(ciphertext_set);
		}	
		c = 0;	//reset constant for next ciphertext_sets for next iteration of rk_byte to find
		
		// Save found roundkey byte
		for(n=0; n<256; n++)
		{
			if(candidates[n] == 0x1)
			{
				found_roundkey[rk_byte_num] = n; // take index number as the rk value
				rk_byte_num++;					 // ready to find next byte of roundkey
				printf("0x%x\t", n);
				break;
			}
		}
		memset(candidates, 1, 256);		// reset
	}
	printf("\n");
	return 0;
}







